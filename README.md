<h1 align="center">SymForce</h1>

![images](docs/Logo.png)
SymForce merupakan sebuah code generation library yang digunakan untuk komputasi simbolik cepat dan sering digunakan untuk pengaplikasian metode robotik. Pada umumnya Symforce akan mengkombinasikan development speed dan fleksibelitas simbolik dalam matematika dengan performa yang autogenerated. Untuk implementasi akan lebih optimal menggunakan bahasa pemrograman C++ atau bahasa pemrograman yang memiliki runtime yang cepat. Berikut adalah beberapa contoh pengaplikasian yang dapat menggunakan SymForce :
- Computer Vision
- State Estimation
- Motion Planning
- Robot Controls

SymForce terdiri dari 3 sistem, yaitu :
- Symbolic Toolkit
- Code Generator
- Optimization Library

![images](https://symforce.org/docs/static/images/symforce_diagram.png)

# Disclaimer
Untuk informasi dan Referensi apabila terjadi ERROR dapat melakukan pengecekan pada source berikut :

- Source Code Github : `https://github.com/symforce-org/symforce`.
Hal ini dikarenakan pemanggilan function dan method terdapat pada beberapa path yang telah ada dan penulis hanya melakukan overview dokumentasi.

# Build
Tools and Compatible Version Language
- Python 3.8+ 
- C++14
- CMake

## Features
- Dapat mengimplementasikan simbolik geometri dan juga tipe kamera dengan menggunakan operasi Lie Group
- Dapat meminimalkan bug, mengurangi duplikasi serta pembuatan code generation dengan runtime yang cepat.
- Dapat melakukan komputasi untuk menghitung Tangent Space-Jacobian dengan optimal
- Memiliki flattening computation dan memanfaatkan sparsity yang dapat menghasilkan 10x percepatan apabila dibandingkan dengan autodiff standar
- Termasuk ke dalam Tangent-space Optimization library tercepat berdasarkan grafik faktor untuk bahasa pemrograman C++ dan Python


## Installation

Install menggunakan pip :

```sh
pip install symforce
```
Untuk memudahkan instalisasi bisa melihat requirements.txt : `data/requirements.txt`.

Kemudian untuk verifikasi hasil instalisasi dengan Python

```sh
>>> import symforce.symbolic as sf
>>> sf.Rot3()
```

# Implementasi SymForce 
Contoh Studi Kasus#
Robot bergerak melalui bidang 2D dan memiliki goal untuk memperkirakan pose pada beberapa langkah kedepan dengan sebuah pengukuran kebisingan (noisy measurements). 

Pengukuran yang harus dilakukan oleh Robot :

 * Jarak yang ditempuh dengan menggunakan sensor odometri
 * Sudut relatif menuju landmark.

Berdasarkan kasus di atas, maka robot memiiki sudut dengan tujuan yang berlawanan arah jarum jam dari sumbu x. Oleh karena itu, pengukuran sudut relatif ditentukan dari arah robot akan maju. Berikut adalah gambar berdasarkan kasus robot yang kita miliki :

![images](https://github.com/symforce-org/symforce/raw/main/docs/static/images/robot_2d_localization/problem_setup.png)


## Perhitungan matematika

Hal pertama yang harus kita lakukan adalah melakukan import librari symforce yang berisikan API SymPy dan untuk kasus ini kita akan menggunakan symbolic untuk dapat mengimplementasikan kasus di atas:
```python
import symforce.symbolic as sf
```

Create a symbolic 2D pose and landmark location. Using symbolic variables lets us explore and build up the math in a pure form.
```python
pose = sf.Pose2(
    t=sf.V2.symbolic("t"),
    R=sf.Rot2.symbolic("R")
)
landmark = sf.V2.symbolic("L")
```

Let's transform the landmark into the local frame of the robot.  We choose to represent poses as
`world_T_body`, meaning that to take a landmark in the world frame and get its position in the body
frame, we do:
```python
landmark_body = pose.inverse() * landmark
```
![images](docs/pose.png)

You can see that `sf.Rot2` is represented internally by a complex number (ð‘…ð‘Ÿð‘’, ð‘…ð‘–ð‘š) and we can study how it rotates the landmark ð¿.

For exploration purposes, let's take the jacobian of the body-frame landmark with respect to the tangent space of the `Pose2`, parameterized as (ðœƒ, ð‘¥, ð‘¦):

```python
landmark_body.jacobian(pose)
```
![images](docs/pose2.png)

Note that even though the orientation is stored as a complex number, the tangent space is a scalar angle and SymForce understands that.

Now compute the relative bearing angle:

```python
sf.atan2(landmark_body[1], landmark_body[0])
```
![images](docs/atan2.png)

One important note is that `atan2` is singular at (0, 0). In SymForce we handle this by placing a symbol Ïµ (epsilon) that preserves the value of an expression in the limit of Ïµ â†’ 0, but allows evaluating at runtime with a very small nonzero value. Functions with singularities accept an `epsilon` argument:

```python
sf.V3.symbolic("x").norm(epsilon=sf.epsilon())
```
![images](docs/epsilon.png)

See the [Epsilon Tutorial](https://symforce.org/tutorials/epsilon_tutorial.html) in the SymForce Docs for more information.

## Build an optimization problem

We will model this problem as a factor graph and solve it with nonlinear least-squares.

First, we need to tell SymForce to use a nonzero epsilon to prevent singularities.  This isn't necessary when playing around with symbolic expressions like we were above, but it's important now that we want to numerically evaluate some results.  For more information, check out the [Epsilon Tutorial](https://symforce.org/tutorials/epsilon_tutorial.html) - for now, all you need to do is this:

```python
import symforce
symforce.set_epsilon_to_symbol()
```

This needs to be done before other parts of symforce are imported - if you're following along in a
notebook you should add this at the top and restart the kernel.

Now that epsilon is set up, we will instantiate numerical [`Values`](https://symforce.org/api/symforce.values.values.html?highlight=values#module-symforce.values.values) for the problem, including an initial guess for our unknown poses (just set them to identity).

```python
import numpy as np
from symforce.values import Values

num_poses = 3
num_landmarks = 3

initial_values = Values(
    poses=[sf.Pose2.identity()] * num_poses,
    landmarks=[sf.V2(-2, 2), sf.V2(1, -3), sf.V2(5, 2)],
    distances=[1.7, 1.4],
    angles=np.deg2rad([[145, 335, 55], [185, 310, 70], [215, 310, 70]]).tolist(),
    epsilon=sf.numeric_epsilon,
)
```

Next, we can set up the factors connecting our variables.  The residual function comprises of two terms - one for the bearing measurements and one for the odometry measurements. Let's formalize the math we just defined for the bearing measurements into a symbolic residual function:

```python
def bearing_residual(
    pose: sf.Pose2, landmark: sf.V2, angle: sf.Scalar, epsilon: sf.Scalar
) -> sf.V1:
    t_body = pose.inverse() * landmark
    predicted_angle = sf.atan2(t_body[1], t_body[0], epsilon=epsilon)
    return sf.V1(sf.wrap_angle(predicted_angle - angle))
```

This function takes in a pose and landmark variable and returns the error between the predicted bearing angle and a measured value. Note that we call `sf.wrap_angle` on the angle difference to prevent wraparound effects.

The residual for distance traveled is even simpler:

```python
def odometry_residual(
    pose_a: sf.Pose2, pose_b: sf.Pose2, dist: sf.Scalar, epsilon: sf.Scalar
) -> sf.V1:
    return sf.V1((pose_b.t - pose_a.t).norm(epsilon=epsilon) - dist)
```

Now we can create [`Factor`](https://symforce.org/api/symforce.opt.factor.html?highlight=factor#module-symforce.opt.factor) objects from the residual functions and a set of keys. The keys are named strings for the function arguments, which will be accessed by name from a [`Values`](https://symforce.org/api/symforce.values.values.html) class we later instantiate with numerical quantities.

```python
from symforce.opt.factor import Factor

factors = []

# Bearing factors
for i in range(num_poses):
    for j in range(num_landmarks):
        factors.append(Factor(
            residual=bearing_residual,
            keys=[f"poses[{i}]", f"landmarks[{j}]", f"angles[{i}][{j}]", "epsilon"],
        ))

# Odometry factors
for i in range(num_poses - 1):
    factors.append(Factor(
        residual=odometry_residual,
        keys=[f"poses[{i}]", f"poses[{i + 1}]", f"distances[{i}]", "epsilon"],
    ))
```

Here is a visualization of the structure of this factor graph:
![images](docs/Visualisasi.png)

## Solve the problem

Our goal is to find poses of the robot that minimize the residual of this factor graph, assuming the landmark positions in the world are known. We create an [`Optimizer`](https://symforce.org/api/symforce.opt.optimizer.html?highlight=optimizer#module-symforce.opt.optimizer)with these factors and tell it to only optimize the pose keys (the rest are held constant):
```python
from symforce.opt.optimizer import Optimizer

optimizer = Optimizer(
    factors=factors,
    optimized_keys=[f"poses[{i}]" for i in range(num_poses)],
    # So that we save more information about each iteration, to visualize later:
    debug_stats=True,
)
```

Now run the optimization! This returns an [`Optimizer.Result`](https://symforce.org/api/symforce.opt.optimizer.html?highlight=optimizer#symforce.opt.optimizer.Optimizer.Result) object that contains the optimized values, error statistics, and per-iteration debug stats (if enabled).
```python
result = optimizer.optimize(initial_values)
```

Let's visualize what the optimizer did. The orange circles represent the fixed landmarks, the blue
circles represent the robot, and the dotted lines represent the bearing measurements.

```python
from data.plotting import plot_solution
plot_solution(optimizer, result)
```
![gif](docs/iterations.gif)

Source Code `data/2D_RobotLocalization.py`.
